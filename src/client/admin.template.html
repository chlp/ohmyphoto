<!-- GENERATED FILE: edit `src/client/admin.template.html` and run `node scripts/build-assets.mjs` -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Admin | OhMyPhoto</title>
  <meta name="robots" content="noindex,nofollow" />
  <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    input, textarea, button { font: inherit; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .card { border: 1px solid #ddd; border-radius: 8px; padding: 16px; margin: 12px 0; }
    .muted { color: #666; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; vertical-align: top; }
    textarea { width: 100%; min-height: 80px; }
    .small { font-size: 12px; }
    .danger { background: #b42318; color: #fff; border: 0; padding: 8px 12px; border-radius: 6px; }
    .primary { background: #175cd3; color: #fff; border: 0; padding: 8px 12px; border-radius: 6px; }
    .ghost { background: #fff; border: 1px solid #ccc; padding: 8px 12px; border-radius: 6px; }
    code { background: #f6f6f6; padding: 2px 4px; border-radius: 4px; }
    .hidden { display: none; }
    .grid { display: grid; gap: 12px; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); }
    .thumb { width: 100%; height: 160px; object-fit: cover; border-radius: 8px; border: 1px solid #eee; background: #fafafa; }
    .fileCard { border: 1px solid #eee; border-radius: 10px; padding: 12px; }
    .fileActions { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <h1>OhMyPhoto Admin</h1>

  <!-- Turnstile widget container (kept off-screen to avoid layout impact) -->
  <div id="turnstile-widget" style="position:absolute;left:-9999px;top:0;width:1px;height:1px;overflow:hidden;"></div>

  <div class="card">
    <h2>Auth</h2>
    <div class="row">
      <label>Admin token:</label>
      <input id="token" type="password" placeholder="ADMIN_TOKEN" style="min-width:280px" />
      <button class="ghost" id="saveToken">Login</button>
      <button class="ghost" id="logout">Logout</button>
    </div>
    <div class="muted small" id="authInfo"></div>
  </div>

  <div class="card">
    <h2>Create album</h2>
    <div class="row">
      <label>Album ID:</label>
      <input id="newAlbumId" placeholder="abc" />
      <label>Title:</label>
      <input id="newTitle" placeholder="OhMyPhoto" style="min-width:280px" />
      <button class="primary" id="createBtn">Create</button>
    </div>
  </div>

  <div class="card" id="albumsCard">
    <div class="row" style="justify-content: space-between;">
      <h2 style="margin:0">Albums</h2>
      <button class="ghost" id="refreshBtn">Refresh</button>
    </div>
    <div id="status" class="muted small"></div>
    <div style="overflow:auto;">
      <table>
        <thead>
          <tr>
            <th>albumId</th>
            <th>title</th>
            <th>secrets (one per line)</th>
            <th>rename</th>
            <th>photos</th>
            <th>actions</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>

  <div class="card hidden" id="editorCard">
    <div class="row" style="justify-content: space-between;">
      <div>
        <h2 style="margin:0">Edit album: <code id="editAlbumId" class="mono"></code></h2>
        <div class="muted small" id="filesStatus"></div>
      </div>
      <div class="row">
        <button class="ghost" id="backToAlbumsBtn">Back</button>
        <button class="ghost" id="refreshFilesBtn">Refresh files</button>
      </div>
    </div>

    <div class="card" style="margin-top:12px;">
      <h3 style="margin-top:0;">Upload photos</h3>
      <div class="row">
        <input id="uploadInput" type="file" accept="image/*" multiple />
        <label class="row" style="gap:6px;">
          <input id="overwriteUpload" type="checkbox" />
          overwrite existing
        </label>
        <button class="primary" id="uploadBtn">Upload selected</button>
      </div>
      <div class="muted small" id="uploadStatus"></div>
    </div>

    <h3>Files</h3>
    <div id="filesGrid" class="grid"></div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);
    const tokenEl = $('token');
    const statusEl = $('status');
    const authInfoEl = $('authInfo');
    const albumsCardEl = $('albumsCard');
    const editorCardEl = $('editorCard');
    const editAlbumIdEl = $('editAlbumId');
    const filesStatusEl = $('filesStatus');
    const filesGridEl = $('filesGrid');
    const uploadInputEl = $('uploadInput');
    const uploadStatusEl = $('uploadStatus');

    // Cloudflare Turnstile site key (injected by build step)
    const TURNSTILE_SITE_KEY = '__TURNSTILE_SITE_KEY__';

    let currentEditAlbumId = '';
    let currentEditSecret = '';

    function base64UrlDecodeToJson(b64url) {
      try {
        const b64 = b64url.replace(/-/g, '+').replace(/_/g, '/');
        const pad = b64.length % 4 === 0 ? '' : '='.repeat(4 - (b64.length % 4));
        const jsonStr = atob(b64 + pad);
        return JSON.parse(jsonStr);
      } catch {
        return null;
      }
    }

    async function getTurnstileTokenOnce() {
      if (!TURNSTILE_SITE_KEY || TURNSTILE_SITE_KEY === 'YOUR_TURNSTILE_SITE_KEY') return '';
      try {
        // Wait for Turnstile script to load (poll with timeout)
        await new Promise((resolve) => {
          const startedAt = Date.now();
          const tick = () => {
            if (typeof turnstile !== 'undefined') return resolve();
            if (Date.now() - startedAt > 3000) return resolve(); // 3s timeout
            setTimeout(tick, 50);
          };
          tick();
        });

        if (typeof turnstile === 'undefined') return '';

        return await new Promise((resolve) => {
          let resolved = false;
          const timeout = setTimeout(() => {
            if (!resolved) {
              resolved = true;
              resolve(''); // Timeout - continue without token
            }
          }, 5000);

          const widgetId = turnstile.render('#turnstile-widget', {
            sitekey: TURNSTILE_SITE_KEY,
            callback: (token) => {
              if (!resolved) {
                resolved = true;
                clearTimeout(timeout);
                resolve(token);
              }
            },
            'error-callback': () => {
              if (!resolved) {
                resolved = true;
                clearTimeout(timeout);
                resolve(''); // Continue without token on error
              }
            },
            size: 'normal',
            execution: 'execute'
          });

          try { turnstile.reset(widgetId); } catch {}
          try { turnstile.execute(widgetId); } catch { resolve(''); }
        });
      } catch (err) {
        return '';
      }
    }

    function getSessionToken() {
      return localStorage.getItem('ohmyphoto_admin_session') || '';
    }
    function setSessionToken(t) {
      localStorage.setItem('ohmyphoto_admin_session', t);
    }
    function clearSessionToken() {
      localStorage.removeItem('ohmyphoto_admin_session');
    }

    function getSessionPayload(sessionToken) {
      const t = String(sessionToken || '');
      const parts = t.split('.');
      if (parts.length !== 2) return null;
      return base64UrlDecodeToJson(parts[0]);
    }

    function enforceSessionFreshness() {
      const t = getSessionToken();
      if (!t) {
        authInfoEl.textContent = 'No session. Please login.';
        return;
      }
      const payload = getSessionPayload(t);
      if (!payload || typeof payload.iat !== 'number' || typeof payload.exp !== 'number') {
        clearSessionToken();
        authInfoEl.textContent = 'Invalid session. Please login again.';
        return;
      }
      const now = Date.now();
      if (payload.exp <= now) {
        clearSessionToken();
        authInfoEl.textContent = 'Session expired. Please login again.';
        return;
      }
      const ageMs = now - payload.iat;
      const twelveHoursMs = 5 * 24 * 60 * 60 * 1000;
      if (ageMs > twelveHoursMs) {
        clearSessionToken();
        authInfoEl.textContent = 'Session is old. Please login again.';
        return;
      }
      const hoursLeft = Math.max(0, Math.floor((payload.exp - now) / (60 * 60 * 1000)));
      authInfoEl.textContent = `Session OK. ~${hoursLeft}h left.`;
    }

    enforceSessionFreshness();

    $('logout').onclick = () => {
      clearSessionToken();
      authInfoEl.textContent = 'Logged out. Please login.';
      refresh().catch(() => {});
    };

    $('saveToken').onclick = async () => {
      const adminToken = tokenEl.value || '';
      if (!adminToken) {
        statusEl.textContent = 'Enter admin token.';
        return;
      }
      statusEl.textContent = 'Logging in...';
      const turnstileToken = await getTurnstileTokenOnce();
      const resp = await fetch('/api/admin/session', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token: adminToken, turnstileToken })
      });
      if (!resp.ok) {
        statusEl.textContent = `Login failed: ${resp.status}`;
        return;
      }
      const data = await resp.json();
      if (!data.sessionToken) {
        statusEl.textContent = 'Login failed: no session token';
        return;
      }
      setSessionToken(data.sessionToken);
      tokenEl.value = '';
      enforceSessionFreshness();
      statusEl.textContent = 'Logged in.';
      await refresh();
    };

    async function api(path, options = {}) {
      enforceSessionFreshness();
      const token = getSessionToken();
      const headers = { ...(options.headers || {}) };
      if (token) headers['Authorization'] = `Bearer ${token}`;
      return fetch(path, { ...options, headers });
    }

    function parseSecrets(text) {
      return (text || '')
        .split('\n')
        .map(s => s.trim())
        .filter(Boolean);
    }

    function showEditor(albumId, secret) {
      currentEditAlbumId = String(albumId || '');
      currentEditSecret = String(secret || '');
      editAlbumIdEl.textContent = currentEditAlbumId;
      albumsCardEl.classList.add('hidden');
      editorCardEl.classList.remove('hidden');
      filesGridEl.innerHTML = '';
      filesStatusEl.textContent = '';
      uploadStatusEl.textContent = '';
      uploadInputEl.value = '';
    }

    function hideEditor() {
      currentEditAlbumId = '';
      currentEditSecret = '';
      editorCardEl.classList.add('hidden');
      albumsCardEl.classList.remove('hidden');
    }

    async function sha256Hex(input) {
      const data = new TextEncoder().encode(String(input));
      const hash = await crypto.subtle.digest("SHA-256", data);
      const bytes = new Uint8Array(hash);
      let hex = "";
      for (const b of bytes) hex += b.toString(16).padStart(2, "0");
      return hex;
    }

    async function imageSig(albumId, name, secret) {
      return sha256Hex(`${albumId}:${name}:${secret}`);
    }

    function normalizeUploadName(filename) {
      const raw = String(filename || '').replace(/^.*[\\/]/, '');
      const base = raw.replace(/\.[^.]+$/, '');
      let s = base;
      try { s = s.normalize('NFKD'); } catch {}
      s = s.replace(/[^\w.-]+/g, '-'); // keep ascii-ish
      s = s.replace(/-+/g, '-').replace(/^-+|-+$/g, '');
      s = (s || 'photo').slice(0, 80);
      return `${s}.jpg`;
    }

    async function toJpegBlob(file, maxDim) {
      const bmp = await createImageBitmap(file);
      const scale = Math.min(1, maxDim / Math.max(bmp.width, bmp.height));
      const w = Math.max(1, Math.round(bmp.width * scale));
      const h = Math.max(1, Math.round(bmp.height * scale));
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d', { alpha: false });
      ctx.drawImage(bmp, 0, 0, w, h);
      try { bmp.close && bmp.close(); } catch {}
      return await new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) return reject(new Error('JPEG encode failed'));
          resolve(blob);
        }, 'image/jpeg', 0.9);
      });
    }

    async function refreshFiles() {
      if (!currentEditAlbumId) return;
      if (!currentEditSecret) {
        filesStatusEl.textContent = 'Error: album has no secrets. Add at least one secret and Save.';
        return;
      }
      filesStatusEl.textContent = 'Loading files...';
      filesGridEl.innerHTML = '';
      const resp = await api(`/api/admin/album/${encodeURIComponent(currentEditAlbumId)}/files`, { method: 'GET' });
      if (!resp.ok) {
        filesStatusEl.textContent = `Error: ${resp.status}`;
        return;
      }
      const data = await resp.json();
      const files = data.files || [];
      filesStatusEl.textContent = `Files: ${files.length}`;

      for (const f of files) {
        const card = document.createElement('div');
        card.className = 'fileCard';

        const sig = await imageSig(currentEditAlbumId, f.name, currentEditSecret);
        const qs = `?s=${sig}`;
        const previewSignedUrl = `/img/${encodeURIComponent(currentEditAlbumId)}/preview/${encodeURIComponent(f.name)}${qs}`;
        const photoSignedUrl = `/img/${encodeURIComponent(currentEditAlbumId)}/photos/${encodeURIComponent(f.name)}${qs}`;

        const imgLink = document.createElement('a');
        imgLink.href = photoSignedUrl;
        imgLink.title = 'Open full-size';
        imgLink.target = '_blank';
        imgLink.rel = 'noreferrer';

        const img = document.createElement('img');
        img.className = 'thumb';
        img.loading = 'lazy';
        img.alt = f.name;
        img.src = previewSignedUrl;
        imgLink.appendChild(img);
        card.appendChild(imgLink);

        const nameRow = document.createElement('div');
        nameRow.className = 'row';
        nameRow.style.marginTop = '10px';

        const nameInput = document.createElement('input');
        nameInput.value = f.name;
        nameInput.style.flex = '1';
        nameInput.className = 'mono';
        nameRow.appendChild(nameInput);
        card.appendChild(nameRow);

        const actions = document.createElement('div');
        actions.className = 'fileActions';
        actions.style.marginTop = '8px';

        const renameBtn = document.createElement('button');
        renameBtn.className = 'ghost';
        renameBtn.textContent = 'Rename';
        renameBtn.onclick = async () => {
          const newName = nameInput.value.trim();
          if (!newName) return alert('new name required');
          const r = await api(`/api/admin/album/${encodeURIComponent(currentEditAlbumId)}/file/${encodeURIComponent(f.name)}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ newName })
          });
          if (!r.ok) {
            const t = await r.text();
            alert(`Rename failed: ${r.status} ${t}`);
            return;
          }
          await refreshFiles();
        };

        const delBtn = document.createElement('button');
        delBtn.className = 'danger';
        delBtn.textContent = 'Delete';
        delBtn.onclick = async () => {
          if (!confirm(`Delete "${f.name}"?`)) return;
          const r = await api(`/api/admin/album/${encodeURIComponent(currentEditAlbumId)}/file/${encodeURIComponent(f.name)}`, {
            method: 'DELETE'
          });
          if (!r.ok) {
            const t = await r.text();
            alert(`Delete failed: ${r.status} ${t}`);
            return;
          }
          await refreshFiles();
        };

        actions.appendChild(renameBtn);
        actions.appendChild(delBtn);
        card.appendChild(actions);

        const note = document.createElement('div');
        note.className = 'muted small';
        note.textContent = f.hasPreview ? '' : 'preview missing';
        card.appendChild(note);

        filesGridEl.appendChild(card);
      }
    }

    async function uploadSelected() {
      if (!currentEditAlbumId) return;
      const list = Array.from(uploadInputEl.files || []);
      if (!list.length) return alert('Select files first');
      const overwrite = $('overwriteUpload').checked;
      uploadStatusEl.textContent = `Processing ${list.length} file(s)...`;

      for (let i = 0; i < list.length; i++) {
        const file = list[i];
        const outName = normalizeUploadName(file.name);
        uploadStatusEl.textContent = `(${i + 1}/${list.length}) Converting ${file.name} -> ${outName} ...`;
        let photoBlob, previewBlob;
        try {
          photoBlob = await toJpegBlob(file, 3000);
          previewBlob = await toJpegBlob(file, 1000);
        } catch (e) {
          console.error(e);
          uploadStatusEl.textContent = `Failed to process ${file.name}: ${String(e)}`;
          return;
        }

        const fd = new FormData();
        fd.append('name', outName);
        fd.append('overwrite', overwrite ? '1' : '0');
        fd.append('photo', new File([photoBlob], outName, { type: 'image/jpeg' }));
        fd.append('preview', new File([previewBlob], outName, { type: 'image/jpeg' }));

        uploadStatusEl.textContent = `(${i + 1}/${list.length}) Uploading ${outName} ...`;
        const r = await api(`/api/admin/album/${encodeURIComponent(currentEditAlbumId)}/file`, {
          method: 'POST',
          body: fd
        });
        if (!r.ok) {
          const t = await r.text();
          uploadStatusEl.textContent = `Upload failed (${outName}): ${r.status} ${t}`;
          return;
        }
      }

      uploadStatusEl.textContent = 'Upload complete.';
      uploadInputEl.value = '';
      await refreshFiles();
    }

    async function refresh() {
      statusEl.textContent = 'Loading...';
      const resp = await api('/api/admin/albums', { method: 'GET' });
      if (resp.status === 401) {
        statusEl.textContent = 'Unauthorized (401). Set ADMIN_TOKEN.';
        $('tbody').innerHTML = '';
        return;
      }
      if (!resp.ok) {
        statusEl.textContent = `Error: ${resp.status}`;
        return;
      }
      const data = await resp.json();
      const albums = data.albums || [];

      const tbody = $('tbody');
      tbody.innerHTML = '';
      for (const a of albums) {
        const tr = document.createElement('tr');

        const tdId = document.createElement('td');
        tdId.textContent = a.albumId;
        tr.appendChild(tdId);

        const tdTitle = document.createElement('td');
        const titleInput = document.createElement('input');
        titleInput.value = a.title || 'OhMyPhoto';
        titleInput.style.minWidth = '220px';
        tdTitle.appendChild(titleInput);
        tr.appendChild(tdTitle);

        const tdSecrets = document.createElement('td');
        const secretsArea = document.createElement('textarea');
        secretsArea.placeholder = '';
        // Prevent password managers / autofill extensions from trying to hook into this field.
        // Some extensions inject buggy content scripts and can crash on focus.
        secretsArea.setAttribute('autocomplete', 'off');
        secretsArea.setAttribute('autocorrect', 'off');
        secretsArea.setAttribute('autocapitalize', 'none');
        secretsArea.setAttribute('spellcheck', 'false');
        secretsArea.setAttribute('inputmode', 'text');
        secretsArea.setAttribute('data-lpignore', 'true');   // LastPass
        secretsArea.setAttribute('data-1p-ignore', 'true');  // 1Password
        secretsArea.setAttribute('data-bwignore', 'true');   // Bitwarden
        secretsArea.setAttribute('data-form-type', 'other'); // generic hint for some autofill engines
        // Prefill existing secrets (one per line)
        secretsArea.value = (a.secrets || []).join('\n');
        tdSecrets.appendChild(secretsArea);
        const hint = document.createElement('div');
        hint.className = 'muted small';
        hint.textContent = `Current count: ${a.secretCount || 0}`;
        tdSecrets.appendChild(hint);
        tr.appendChild(tdSecrets);

        const tdRename = document.createElement('td');
        const renameInput = document.createElement('input');
        renameInput.placeholder = 'new-album-id';
        tdRename.appendChild(renameInput);
        tr.appendChild(tdRename);

        const tdPhotos = document.createElement('td');
        const editBtn = document.createElement('button');
        editBtn.className = 'ghost';
        editBtn.textContent = 'Edit';
        editBtn.onclick = async () => {
          const secret = (a.secrets || [])[0] || '';
          if (!secret) {
            alert('Album has no secrets. Add at least one secret and Save first.');
            return;
          }
          showEditor(a.albumId, secret);
          await refreshFiles();
        };
        tdPhotos.appendChild(editBtn);
        tr.appendChild(tdPhotos);

        const tdActions = document.createElement('td');
        const saveBtn = document.createElement('button');
        saveBtn.className = 'primary';
        saveBtn.textContent = 'Save';
        saveBtn.onclick = async () => {
          const payload = { title: titleInput.value || 'OhMyPhoto' };
          // Always send secrets (allows clearing); textarea is prefilled from server.
          payload.secrets = parseSecrets(secretsArea.value);
          if (renameInput.value.trim()) payload.newAlbumId = renameInput.value.trim();
          const r = await api(`/api/admin/album/${encodeURIComponent(a.albumId)}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          if (!r.ok) {
            alert(`Save failed: ${r.status}`);
            return;
          }
          await refresh();
        };

        const delBtn = document.createElement('button');
        delBtn.className = 'danger';
        delBtn.textContent = 'Delete';
        delBtn.onclick = async () => {
          if (!confirm(`Delete album "${a.albumId}" and ALL its photos?`)) return;
          const r = await api(`/api/admin/album/${encodeURIComponent(a.albumId)}`, { method: 'DELETE' });
          if (!r.ok) {
            alert(`Delete failed: ${r.status}`);
            return;
          }
          await refresh();
        };

        tdActions.appendChild(saveBtn);
        tdActions.appendChild(document.createTextNode(' '));
        tdActions.appendChild(delBtn);
        tr.appendChild(tdActions);

        tbody.appendChild(tr);
      }
      statusEl.textContent = `Albums: ${albums.length}`;
    }

    $('refreshBtn').onclick = refresh;
    $('backToAlbumsBtn').onclick = () => hideEditor();
    $('refreshFilesBtn').onclick = () => refreshFiles().catch(() => {});
    $('uploadBtn').onclick = () => uploadSelected().catch(() => {});

    $('createBtn').onclick = async () => {
      const albumId = $('newAlbumId').value.trim();
      const title = $('newTitle').value.trim() || 'OhMyPhoto';
      if (!albumId) return alert('albumId required');
      const r = await api('/api/admin/album', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ albumId, title })
      });
      if (!r.ok) {
        const t = await r.text();
        alert(`Create failed: ${r.status} ${t}`);
        return;
      }
      $('newAlbumId').value = '';
      await refresh();
    };

    refresh().catch(err => {
      statusEl.textContent = String(err);
    });
  </script>
</body>
</html>


