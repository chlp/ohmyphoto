<!-- GENERATED FILE: edit `src/client/admin.template.html` and run `node scripts/build-assets.mjs` -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Admin | OhMyPhoto</title>
  <meta name="robots" content="noindex,nofollow" />
  <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    input, textarea, button { font: inherit; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .card { border: 1px solid #ddd; border-radius: 8px; padding: 16px; margin: 12px 0; }
    .muted { color: #666; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; vertical-align: top; }
    textarea { width: 100%; min-height: 80px; }
    .small { font-size: 12px; }
    .danger { background: #b42318; color: #fff; border: 0; padding: 8px 12px; border-radius: 6px; }
    .primary { background: #175cd3; color: #fff; border: 0; padding: 8px 12px; border-radius: 6px; }
    .ghost { background: #fff; border: 1px solid #ccc; padding: 8px 12px; border-radius: 6px; }
    .genBtn { min-width: 112px; }
    code { background: #f6f6f6; padding: 2px 4px; border-radius: 4px; }
    .hidden { display: none; }
    .grid { display: grid; gap: 12px; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); }
    .thumb { width: 100%; height: 160px; object-fit: cover; border-radius: 8px; border: 1px solid #eee; background: #fafafa; }
    .fileCard { border: 1px solid #eee; border-radius: 10px; padding: 12px; }
    .fileActions { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .albumLinks { margin-top: 6px; display: flex; gap: 8px; flex-wrap: wrap; }
    .albumLinks a { font-size: 12px; color: #175cd3; text-decoration: none; }
    .albumLinks a:hover { text-decoration: underline; }
    .albumLinkItem { display: inline-flex; gap: 6px; align-items: center; }
    .qrDetails { display: inline-block; }
    .qrDetails > summary { cursor: pointer; user-select: none; font-size: 11px; color: #666; }
    .qrDetails[open] > summary { color: #111; }
    .qrBox {
      width: 112px;
      height: 112px;
      display: grid;
      place-items: center;
      margin-top: 6px;
      border: 1px solid #eee;
      border-radius: 10px;
      background: #fff;
      overflow: hidden;
    }
    /* Force the generated canvas/svg to fit inside the box */
    .qrBox canvas,
    .qrBox svg,
    .qrBox img {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }
    .qrActions { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 6px; justify-content: center; }
    .qrActions button { font-size: 11px; padding: 5px 8px; border-radius: 6px; }
  </style>
</head>
<body>
  <h1>OhMyPhoto Admin</h1>

  <!-- Turnstile widget container (kept off-screen to avoid layout impact) -->
  <div id="turnstile-widget" style="position:absolute;left:-9999px;top:0;width:1px;height:1px;overflow:hidden;"></div>

  <div class="card">
    <h2>Auth</h2>
    <div class="row">
      <label class="small muted" for="token">Admin token:</label>
      <input id="token" type="password" placeholder="ADMIN_TOKEN" style="min-width:280px" />
      <button class="ghost" id="saveToken">Login</button>
      <button class="ghost" id="logout">Logout</button>
    </div>
    <div class="muted small" id="authInfo"></div>
  </div>

  <div class="card">
    <h2>Create album</h2>
    <div class="row" style="align-items:flex-end;">
      <div style="flex:1;min-width:520px;">
        <label class="small muted" for="newAlbumDesc">AI description (optional):</label>
        <input id="newAlbumDesc" placeholder="семья на пляже" style="width:100%;" />
      </div>
      <button class="ghost genBtn" id="genAlbumIdBtn" title="Generate a short album id (slug) via Workers AI">Generate</button>
    </div>
    <div class="muted small" id="genAlbumIdStatus" style="margin-top:6px;"></div>
    <div class="row" style="align-items:flex-end;margin-top:10px;">
      <div style="flex:1;min-width:520px;">
        <label class="small muted" for="newAlbumId">Album ID:</label>
        <input id="newAlbumId" placeholder="2025.12.25-sunny-family-beach" class="mono" style="width:100%;" />
      </div>
    </div>
    <div class="row" style="align-items:flex-end;margin-top:10px;">
      <div style="flex:1;min-width:420px;">
        <label class="small muted" for="newTitle">Title:</label>
        <input id="newTitle" placeholder="OhMyPhoto" style="width:100%;" />
      </div>
    </div>
    <div class="row" style="align-items:flex-end;margin-top:10px;">
      <div style="flex:1;min-width:520px;">
        <label class="small muted" for="newSecret">Secret:</label>
        <input id="newSecret" class="mono" placeholder="optional (a-zA-Z0-9_-)" style="width:100%;" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="text" data-lpignore="true" data-1p-ignore="true" data-bwignore="true" data-form-type="other" />
      </div>
      <button class="ghost genBtn" id="genSecretBtn" title="Generate a random secret">Generate</button>
    </div>
    <div class="row" style="margin-top:10px;">
      <button class="primary" id="createBtn">Create</button>
    </div>
  </div>

  <div class="card" id="albumsCard">
    <div class="row" style="justify-content: space-between;">
      <h2 style="margin:0">Albums</h2>
      <div class="row">
        <button class="ghost" id="rebuildAllFilesBtn" title="Rebuild info.json.files for ALL albums by listing bucket (may take time)">Rebuild files (all)</button>
        <button class="ghost" id="refreshBtn">Refresh</button>
      </div>
    </div>
    <div id="status" class="muted small"></div>
    <div style="overflow:auto;">
      <table>
        <thead>
          <tr>
            <th>albumId</th>
            <th>title</th>
            <th>secrets (one per line)</th>
            <th>rename</th>
            <th>photos</th>
            <th>actions</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>

  <div class="card hidden" id="editorCard">
    <div class="row" style="justify-content: space-between;">
      <div>
        <h2 style="margin:0">Edit album: <code id="editAlbumId" class="mono"></code></h2>
        <div class="muted small" id="filesStatus"></div>
      </div>
      <div class="row">
        <button class="ghost" id="backToAlbumsBtn">Back</button>
        <button class="ghost" id="refreshFilesBtn">Refresh files</button>
        <button class="ghost" id="rebuildFilesBtn" title="Rebuild info.json.files by listing bucket (photos/ + preview/)">Rebuild files</button>
      </div>
    </div>

    <div class="card" style="margin-top:12px;">
      <h3 style="margin-top:0;">Upload photos</h3>
      <div class="row">
        <input id="uploadInput" type="file" accept="image/*" multiple />
        <label class="row small muted" style="gap:6px;">
          <input id="overwriteUpload" type="checkbox" />
          overwrite existing
        </label>
        <button class="primary" id="uploadBtn">Upload selected</button>
      </div>
      <div class="muted small" id="uploadStatus"></div>
    </div>

    <h3>Files</h3>
    <div id="filesGrid" class="grid"></div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);
    const tokenEl = $('token');
    const statusEl = $('status');
    const authInfoEl = $('authInfo');
    const genAlbumIdStatusEl = $('genAlbumIdStatus');
    const albumsCardEl = $('albumsCard');
    const editorCardEl = $('editorCard');
    const editAlbumIdEl = $('editAlbumId');
    const filesStatusEl = $('filesStatus');
    const filesGridEl = $('filesGrid');
    const uploadInputEl = $('uploadInput');
    const uploadStatusEl = $('uploadStatus');

    // Cloudflare Turnstile site key (injected by build step)
    const TURNSTILE_SITE_KEY = '__TURNSTILE_SITE_KEY__';

    let currentEditAlbumId = '';
    let currentEditSecret = '';

    function base64UrlDecodeToJson(b64url) {
      try {
        const b64 = b64url.replace(/-/g, '+').replace(/_/g, '/');
        const pad = b64.length % 4 === 0 ? '' : '='.repeat(4 - (b64.length % 4));
        const jsonStr = atob(b64 + pad);
        return JSON.parse(jsonStr);
      } catch {
        return null;
      }
    }

    async function getTurnstileTokenOnce() {
      if (!TURNSTILE_SITE_KEY || TURNSTILE_SITE_KEY === 'YOUR_TURNSTILE_SITE_KEY') return '';
      try {
        // Wait for Turnstile script to load (poll with timeout)
        await new Promise((resolve) => {
          const startedAt = Date.now();
          const tick = () => {
            if (typeof turnstile !== 'undefined') return resolve();
            if (Date.now() - startedAt > 3000) return resolve(); // 3s timeout
            setTimeout(tick, 50);
          };
          tick();
        });

        if (typeof turnstile === 'undefined') return '';

        return await new Promise((resolve) => {
          let resolved = false;
          const timeout = setTimeout(() => {
            if (!resolved) {
              resolved = true;
              resolve(''); // Timeout - continue without token
            }
          }, 5000);

          const widgetId = turnstile.render('#turnstile-widget', {
            sitekey: TURNSTILE_SITE_KEY,
            callback: (token) => {
              if (!resolved) {
                resolved = true;
                clearTimeout(timeout);
                resolve(token);
              }
            },
            'error-callback': () => {
              if (!resolved) {
                resolved = true;
                clearTimeout(timeout);
                resolve(''); // Continue without token on error
              }
            },
            size: 'normal',
            execution: 'execute'
          });

          try { turnstile.reset(widgetId); } catch {}
          try { turnstile.execute(widgetId); } catch { resolve(''); }
        });
      } catch (err) {
        return '';
      }
    }

    function getSessionToken() {
      return localStorage.getItem('ohmyphoto_admin_session') || '';
    }
    function setSessionToken(t) {
      localStorage.setItem('ohmyphoto_admin_session', t);
    }
    function clearSessionToken() {
      localStorage.removeItem('ohmyphoto_admin_session');
    }

    function getSessionPayload(sessionToken) {
      const t = String(sessionToken || '');
      const parts = t.split('.');
      if (parts.length !== 2) return null;
      return base64UrlDecodeToJson(parts[0]);
    }

    function enforceSessionFreshness() {
      const t = getSessionToken();
      if (!t) {
        authInfoEl.textContent = 'No session. Please login.';
        return;
      }
      const payload = getSessionPayload(t);
      if (!payload || typeof payload.iat !== 'number' || typeof payload.exp !== 'number') {
        clearSessionToken();
        authInfoEl.textContent = 'Invalid session. Please login again.';
        return;
      }
      const now = Date.now();
      if (payload.exp <= now) {
        clearSessionToken();
        authInfoEl.textContent = 'Session expired. Please login again.';
        return;
      }
      const ageMs = now - payload.iat;
      const twelveHoursMs = 5 * 24 * 60 * 60 * 1000;
      if (ageMs > twelveHoursMs) {
        clearSessionToken();
        authInfoEl.textContent = 'Session is old. Please login again.';
        return;
      }
      const hoursLeft = Math.max(0, Math.floor((payload.exp - now) / (60 * 60 * 1000)));
      authInfoEl.textContent = `Session OK. ~${hoursLeft}h left.`;
    }

    enforceSessionFreshness();

    $('logout').onclick = () => {
      clearSessionToken();
      authInfoEl.textContent = 'Logged out. Please login.';
      refresh().catch(() => {});
    };

    $('saveToken').onclick = async () => {
      const adminToken = tokenEl.value || '';
      if (!adminToken) {
        statusEl.textContent = 'Enter admin token.';
        return;
      }
      statusEl.textContent = 'Logging in...';
      const turnstileToken = await getTurnstileTokenOnce();
      const resp = await fetch('/api/admin/session', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token: adminToken, turnstileToken })
      });
      if (!resp.ok) {
        statusEl.textContent = `Login failed: ${resp.status}`;
        return;
      }
      const data = await resp.json();
      if (!data.sessionToken) {
        statusEl.textContent = 'Login failed: no session token';
        return;
      }
      setSessionToken(data.sessionToken);
      tokenEl.value = '';
      enforceSessionFreshness();
      statusEl.textContent = 'Logged in.';
      await refresh();
    };

    async function api(path, options = {}) {
      enforceSessionFreshness();
      const token = getSessionToken();
      const headers = { ...(options.headers || {}) };
      if (token) headers['Authorization'] = `Bearer ${token}`;
      return fetch(path, { ...options, headers });
    }

    function parseSecrets(text) {
      return (text || '')
        .split('\n')
        .map(s => s.trim())
        .filter(Boolean);
    }

    // Styled QR (browser-only) via ESM CDN import (no server-side generation)
    // Vendored ESM build (keeps admin working without external CDNs)
    const QR_CODE_STYLING_URL = '/vendor/qr-code-styling.esm.js';
    let __qrLibPromise = null;
    async function loadQrCodeStyling() {
      if (!__qrLibPromise) {
        __qrLibPromise = import(QR_CODE_STYLING_URL).then((m) => m.default || m.QRCodeStyling || m);
      }
      return __qrLibPromise;
    }
    const __qrInstances = new WeakMap(); // detailsEl -> QRCodeStyling instance

    async function ensureAdminQr(detailsEl, boxEl, data) {
      if (!detailsEl || !boxEl) return null;
      const d = String(data || '');
      if (!d) return null;

      const existing = __qrInstances.get(detailsEl);
      if (existing) {
        try { existing.update({ data: d }); } catch {}
        return existing;
      }

      boxEl.textContent = 'Loading…';
      try {
        const QRCodeStyling = await loadQrCodeStyling();
        const qr = new QRCodeStyling({
          width: 256,
          height: 256,
          type: 'canvas',
          data: d,
          margin: 12,
          qrOptions: { errorCorrectionLevel: 'H' },
          image: '/apple-touch-icon.png',
          imageOptions: { margin: 6, imageSize: 0.28 },
          dotsOptions: {
            type: 'rounded',
            gradient: {
              type: 'linear',
              rotation: Math.PI / 4,
              colorStops: [
                { offset: 0, color: '#111827' },
                { offset: 1, color: '#175cd3' },
              ],
            }
          },
          cornersSquareOptions: { type: 'extra-rounded', color: '#111827' },
          cornersDotOptions: { type: 'dot', color: '#111827' },
          backgroundOptions: { color: '#FFFFFF' },
        });
        boxEl.textContent = '';
        qr.append(boxEl);
        // Defensive: ensure the inserted element scales down to the container
        const inserted = boxEl.querySelector('canvas,svg,img');
        if (inserted) {
          inserted.style.width = '100%';
          inserted.style.height = '100%';
          inserted.style.display = 'block';
        }
        __qrInstances.set(detailsEl, qr);
        return qr;
      } catch (e) {
        console.error('qr-code-styling failed', e);
        boxEl.textContent = 'QR unavailable';
        return null;
      }
    }

    function renderAlbumLinks(containerEl, albumId, secrets) {
      if (!containerEl) return;
      containerEl.innerHTML = '';
      const id = String(albumId || '').trim();
      if (!id) return;

      const list = Array.isArray(secrets) ? secrets : [];
      const uniq = [];
      for (const s of list) {
        const v = String(s || '').trim();
        if (!v) continue;
        if (uniq.includes(v)) continue;
        uniq.push(v);
      }
      if (uniq.length === 0) return;

      for (let i = 0; i < uniq.length; i++) {
        const sec = uniq[i];
        const wrap = document.createElement('span');
        wrap.className = 'albumLinkItem';

        const a = document.createElement('a');
        // Public album URL format: /<albumId>#<secret>
        // IMPORTANT: do not encode secret here; the viewer reads it verbatim from location.hash.
        a.href = `/${encodeURIComponent(id)}#${sec}`;
        a.target = '_blank';
        a.rel = 'noreferrer';
        a.textContent = uniq.length === 1 ? 'open' : `open ${i + 1}`;
        a.title = `/${id}#${sec}`;
        wrap.appendChild(a);

        // Styled QR code (lazy-loaded) for this public URL
        const fullUrl = `${location.origin}/${encodeURIComponent(id)}#${sec}`;
        const d = document.createElement('details');
        d.className = 'qrDetails';
        const s = document.createElement('summary');
        s.textContent = 'QR';
        const box = document.createElement('div');
        box.className = 'qrBox';
        box.setAttribute('aria-label', `QR: ${fullUrl}`);
        const actions = document.createElement('div');
        actions.className = 'qrActions';
        const dlPng = document.createElement('button');
        dlPng.className = 'ghost';
        dlPng.type = 'button';
        dlPng.textContent = 'PNG';
        dlPng.onclick = async () => {
          const qr = await ensureAdminQr(d, box, fullUrl);
          if (qr && typeof qr.download === 'function') {
            await qr.download({ name: `album-${encodeURIComponent(id)}`, extension: 'png' });
          }
        };
        const dlSvg = document.createElement('button');
        dlSvg.className = 'ghost';
        dlSvg.type = 'button';
        dlSvg.textContent = 'SVG';
        dlSvg.onclick = async () => {
          const qr = await ensureAdminQr(d, box, fullUrl);
          if (qr && typeof qr.download === 'function') {
            await qr.download({ name: `album-${encodeURIComponent(id)}`, extension: 'svg' });
          }
        };
        actions.appendChild(dlPng);
        actions.appendChild(dlSvg);
        d.appendChild(s);
        d.appendChild(box);
        d.appendChild(actions);
        d.addEventListener('toggle', () => {
          if (d.open) ensureAdminQr(d, box, fullUrl);
        });
        wrap.appendChild(d);

        containerEl.appendChild(wrap);
      }
    }

    function showEditor(albumId, secret) {
      currentEditAlbumId = String(albumId || '');
      currentEditSecret = String(secret || '');
      editAlbumIdEl.textContent = currentEditAlbumId;
      albumsCardEl.classList.add('hidden');
      editorCardEl.classList.remove('hidden');
      filesGridEl.innerHTML = '';
      filesStatusEl.textContent = '';
      uploadStatusEl.textContent = '';
      uploadInputEl.value = '';
    }

    function hideEditor() {
      currentEditAlbumId = '';
      currentEditSecret = '';
      editorCardEl.classList.add('hidden');
      albumsCardEl.classList.remove('hidden');
    }

    async function sha256Hex(input) {
      const data = new TextEncoder().encode(String(input));
      const hash = await crypto.subtle.digest("SHA-256", data);
      const bytes = new Uint8Array(hash);
      let hex = "";
      for (const b of bytes) hex += b.toString(16).padStart(2, "0");
      return hex;
    }

    async function imageSig(albumId, name, secret) {
      return sha256Hex(`${albumId}:${name}:${secret}`);
    }

    function normalizeUploadName(filename) {
      const raw = String(filename || '').replace(/^.*[\\/]/, '');
      const base = raw.replace(/\.[^.]+$/, '');
      let s = base;
      try { s = s.normalize('NFKD'); } catch {}
      s = s.replace(/[^\w.-]+/g, '-'); // keep ascii-ish
      s = s.replace(/-+/g, '-').replace(/^-+|-+$/g, '');
      s = (s || 'photo').slice(0, 80);
      return `${s}.jpg`;
    }

    async function toJpegBlob(file, maxDim) {
      const bmp = await createImageBitmap(file);
      const scale = Math.min(1, maxDim / Math.max(bmp.width, bmp.height));
      const w = Math.max(1, Math.round(bmp.width * scale));
      const h = Math.max(1, Math.round(bmp.height * scale));
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d', { alpha: false });
      ctx.drawImage(bmp, 0, 0, w, h);
      try { bmp.close && bmp.close(); } catch {}
      return await new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) return reject(new Error('JPEG encode failed'));
          resolve(blob);
        }, 'image/jpeg', 0.9);
      });
    }

    async function refreshFiles() {
      if (!currentEditAlbumId) return;
      if (!currentEditSecret) {
        filesStatusEl.textContent = 'Error: album has no secrets. Add at least one secret and Save.';
        return;
      }
      filesStatusEl.textContent = 'Loading files...';
      filesGridEl.innerHTML = '';
      const resp = await api(`/api/admin/album/${encodeURIComponent(currentEditAlbumId)}/files`, { method: 'GET' });
      if (!resp.ok) {
        filesStatusEl.textContent = `Error: ${resp.status}`;
        return;
      }
      const data = await resp.json();
      const files = data.files || [];
      filesStatusEl.textContent = `Files: ${files.length}`;

      for (const f of files) {
        const card = document.createElement('div');
        card.className = 'fileCard';

        const sig = await imageSig(currentEditAlbumId, f.name, currentEditSecret);
        const qs = `?s=${sig}`;
        const previewSignedUrl = `/img/${encodeURIComponent(currentEditAlbumId)}/preview/${encodeURIComponent(f.name)}${qs}`;
        const photoSignedUrl = `/img/${encodeURIComponent(currentEditAlbumId)}/photos/${encodeURIComponent(f.name)}${qs}`;

        const imgLink = document.createElement('a');
        imgLink.href = photoSignedUrl;
        imgLink.title = 'Open full-size';
        imgLink.target = '_blank';
        imgLink.rel = 'noreferrer';

        const img = document.createElement('img');
        img.className = 'thumb';
        img.loading = 'lazy';
        img.alt = f.name;
        img.src = previewSignedUrl;
        imgLink.appendChild(img);
        card.appendChild(imgLink);

        const nameRow = document.createElement('div');
        nameRow.className = 'row';
        nameRow.style.marginTop = '10px';

        const nameInput = document.createElement('input');
        nameInput.value = f.name;
        nameInput.style.flex = '1';
        nameInput.className = 'mono';
        nameRow.appendChild(nameInput);
        card.appendChild(nameRow);

        const actions = document.createElement('div');
        actions.className = 'fileActions';
        actions.style.marginTop = '8px';

        const renameBtn = document.createElement('button');
        renameBtn.className = 'ghost';
        renameBtn.textContent = 'Rename';
        renameBtn.onclick = async () => {
          const newName = nameInput.value.trim();
          if (!newName) return alert('new name required');
          const r = await api(`/api/admin/album/${encodeURIComponent(currentEditAlbumId)}/file/${encodeURIComponent(f.name)}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ newName })
          });
          if (!r.ok) {
            const t = await r.text();
            alert(`Rename failed: ${r.status} ${t}`);
            return;
          }
          await refreshFiles();
        };

        const delBtn = document.createElement('button');
        delBtn.className = 'danger';
        delBtn.textContent = 'Delete';
        delBtn.onclick = async () => {
          if (!confirm(`Delete "${f.name}"?`)) return;
          const r = await api(`/api/admin/album/${encodeURIComponent(currentEditAlbumId)}/file/${encodeURIComponent(f.name)}`, {
            method: 'DELETE'
          });
          if (!r.ok) {
            const t = await r.text();
            alert(`Delete failed: ${r.status} ${t}`);
            return;
          }
          await refreshFiles();
        };

        actions.appendChild(renameBtn);
        actions.appendChild(delBtn);
        card.appendChild(actions);

        const note = document.createElement('div');
        note.className = 'muted small';
        note.textContent = f.hasPreview ? '' : 'preview missing';
        card.appendChild(note);

        filesGridEl.appendChild(card);
      }
    }

    async function rebuildFiles() {
      if (!currentEditAlbumId) return;
      const btn = $('rebuildFilesBtn');
      if (btn) btn.disabled = true;
      try {
        filesStatusEl.textContent = 'Rebuilding files (listing bucket)...';
        const resp = await api(`/api/admin/album/${encodeURIComponent(currentEditAlbumId)}/rebuild-files`, { method: 'POST' });
        const data = await resp.json().catch(() => null);
        if (!resp.ok || !data || data.ok !== true) {
          filesStatusEl.textContent = `Rebuild error: ${resp.status}`;
          return;
        }
        const added = Array.isArray(data.added) ? data.added.length : 0;
        const removed = Array.isArray(data.removed) ? data.removed.length : 0;
        filesStatusEl.textContent = `Rebuilt. files=${data.fileCount || 0}, +${added}/-${removed}, missingPreview=${data.missingPreviewCount || 0}`;
        await refreshFiles().catch(() => {});
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    async function rebuildAllFiles() {
      const btn = $('rebuildAllFilesBtn');
      if (btn) btn.disabled = true;
      try {
        statusEl.textContent = 'Rebuilding files for all albums (listing bucket)...';
        const resp = await api('/api/admin/albums/rebuild-files', { method: 'POST' });
        const data = await resp.json().catch(() => null);
        if (!resp.ok || !data || data.ok !== true) {
          statusEl.textContent = `Rebuild-all error: ${resp.status}`;
          return;
        }
        statusEl.textContent = `Rebuilt all. albums=${data.albumCount || 0}, ok=${data.albumsOk || 0}, err=${data.albumsErr || 0}, totalFiles=${data.totalFiles || 0}, missingPreview=${data.totalMissingPreview || 0}`;
        await refresh().catch(() => {});
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    async function uploadSelected() {
      if (!currentEditAlbumId) return;
      const list = Array.from(uploadInputEl.files || []);
      if (!list.length) return alert('Select files first');
      const overwrite = $('overwriteUpload').checked;
      uploadStatusEl.textContent = `Processing ${list.length} file(s)...`;

      for (let i = 0; i < list.length; i++) {
        const file = list[i];
        const outName = normalizeUploadName(file.name);
        uploadStatusEl.textContent = `(${i + 1}/${list.length}) Converting ${file.name} -> ${outName} ...`;
        let photoBlob, previewBlob;
        try {
          photoBlob = await toJpegBlob(file, 3000);
          previewBlob = await toJpegBlob(file, 1000);
        } catch (e) {
          console.error(e);
          uploadStatusEl.textContent = `Failed to process ${file.name}: ${String(e)}`;
          return;
        }

        const fd = new FormData();
        fd.append('name', outName);
        fd.append('overwrite', overwrite ? '1' : '0');
        fd.append('photo', new File([photoBlob], outName, { type: 'image/jpeg' }));
        fd.append('preview', new File([previewBlob], outName, { type: 'image/jpeg' }));

        uploadStatusEl.textContent = `(${i + 1}/${list.length}) Uploading ${outName} ...`;
        const r = await api(`/api/admin/album/${encodeURIComponent(currentEditAlbumId)}/file`, {
          method: 'POST',
          body: fd
        });
        if (!r.ok) {
          const t = await r.text();
          uploadStatusEl.textContent = `Upload failed (${outName}): ${r.status} ${t}`;
          return;
        }
      }

      uploadStatusEl.textContent = 'Upload complete.';
      uploadInputEl.value = '';
      await refreshFiles();
    }

    async function refresh() {
      statusEl.textContent = 'Loading...';
      const resp = await api('/api/admin/albums', { method: 'GET' });
      if (resp.status === 401) {
        statusEl.textContent = 'Unauthorized (401). Set ADMIN_TOKEN.';
        $('tbody').innerHTML = '';
        return;
      }
      if (!resp.ok) {
        statusEl.textContent = `Error: ${resp.status}`;
        return;
      }
      const data = await resp.json();
      const albums = data.albums || [];

      const tbody = $('tbody');
      tbody.innerHTML = '';
      for (const a of albums) {
        const tr = document.createElement('tr');

        const tdId = document.createElement('td');
        tdId.textContent = a.albumId;
        tr.appendChild(tdId);

        const tdTitle = document.createElement('td');
        const titleInput = document.createElement('input');
        titleInput.value = a.title || 'OhMyPhoto';
        titleInput.style.minWidth = '220px';
        tdTitle.appendChild(titleInput);
        const links = document.createElement('div');
        links.className = 'albumLinks';
        tdTitle.appendChild(links);
        tr.appendChild(tdTitle);

        const tdSecrets = document.createElement('td');
        const secretsArea = document.createElement('textarea');
        secretsArea.placeholder = '';
        // Prevent password managers / autofill extensions from trying to hook into this field.
        // Some extensions inject buggy content scripts and can crash on focus.
        secretsArea.setAttribute('autocomplete', 'off');
        secretsArea.setAttribute('autocorrect', 'off');
        secretsArea.setAttribute('autocapitalize', 'none');
        secretsArea.setAttribute('spellcheck', 'false');
        secretsArea.setAttribute('inputmode', 'text');
        secretsArea.setAttribute('data-lpignore', 'true');   // LastPass
        secretsArea.setAttribute('data-1p-ignore', 'true');  // 1Password
        secretsArea.setAttribute('data-bwignore', 'true');   // Bitwarden
        secretsArea.setAttribute('data-form-type', 'other'); // generic hint for some autofill engines
        // Prefill existing secrets (one per line)
        secretsArea.value = (a.secrets || []).join('\n');
        tdSecrets.appendChild(secretsArea);
        const hint = document.createElement('div');
        hint.className = 'muted small';
        hint.textContent = `Current count: ${a.secretCount || 0}`;
        tdSecrets.appendChild(hint);
        tr.appendChild(tdSecrets);

        // Render public links next to the title (one per secret)
        renderAlbumLinks(links, a.albumId, parseSecrets(secretsArea.value));
        secretsArea.addEventListener('input', () => {
          renderAlbumLinks(links, a.albumId, parseSecrets(secretsArea.value));
        });

        const tdRename = document.createElement('td');
        const renameInput = document.createElement('input');
        renameInput.placeholder = 'new-album-id';
        tdRename.appendChild(renameInput);
        tr.appendChild(tdRename);

        const tdPhotos = document.createElement('td');
        const editBtn = document.createElement('button');
        editBtn.className = 'ghost';
        editBtn.textContent = 'Edit';
        editBtn.onclick = async () => {
          const secret = (a.secrets || [])[0] || '';
          if (!secret) {
            alert('Album has no secrets. Add at least one secret and Save first.');
            return;
          }
          showEditor(a.albumId, secret);
          await refreshFiles();
        };
        tdPhotos.appendChild(editBtn);
        tr.appendChild(tdPhotos);

        const tdActions = document.createElement('td');
        const saveBtn = document.createElement('button');
        saveBtn.className = 'primary';
        saveBtn.textContent = 'Save';
        saveBtn.onclick = async () => {
          const payload = { title: titleInput.value || 'OhMyPhoto' };
          // Always send secrets (allows clearing); textarea is prefilled from server.
          payload.secrets = parseSecrets(secretsArea.value);
          if (renameInput.value.trim()) payload.newAlbumId = renameInput.value.trim();
          const r = await api(`/api/admin/album/${encodeURIComponent(a.albumId)}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          if (!r.ok) {
            alert(`Save failed: ${r.status}`);
            return;
          }
          await refresh();
        };

        const delBtn = document.createElement('button');
        delBtn.className = 'danger';
        delBtn.textContent = 'Delete';
        delBtn.onclick = async () => {
          if (!confirm(`Delete album "${a.albumId}" and ALL its photos?`)) return;
          const r = await api(`/api/admin/album/${encodeURIComponent(a.albumId)}`, { method: 'DELETE' });
          if (!r.ok) {
            alert(`Delete failed: ${r.status}`);
            return;
          }
          await refresh();
        };

        tdActions.appendChild(saveBtn);
        tdActions.appendChild(document.createTextNode(' '));
        tdActions.appendChild(delBtn);
        tr.appendChild(tdActions);

        tbody.appendChild(tr);
      }
      statusEl.textContent = `Albums: ${albums.length}`;
    }

    $('refreshBtn').onclick = refresh;
    $('rebuildAllFilesBtn').onclick = () => rebuildAllFiles().catch(() => {});
    $('backToAlbumsBtn').onclick = () => hideEditor();
    $('refreshFilesBtn').onclick = () => refreshFiles().catch(() => {});
    $('rebuildFilesBtn').onclick = () => rebuildFiles().catch(() => {});
    $('uploadBtn').onclick = () => uploadSelected().catch(() => {});

    $('createBtn').onclick = async () => {
      const albumId = $('newAlbumId').value.trim();
      const title = $('newTitle').value.trim() || 'OhMyPhoto';
      const secretEl = $('newSecret');
      const secretRaw = secretEl.value.trim();
      if (!albumId) return alert('albumId required');
      const isValidSecret = (s) => /^[a-zA-Z0-9_-]{1,256}$/.test(String(s || ''));
      function randomHex(bytesLen) {
        const bytes = new Uint8Array(bytesLen);
        crypto.getRandomValues(bytes);
        let hex = "";
        for (const b of bytes) hex += b.toString(16).padStart(2, "0");
        return hex;
      }
      function generateSecret6() {
        // 3 bytes => 6 hex chars
        return randomHex(3);
      }
      if (secretRaw && !isValidSecret(secretRaw)) {
        return alert('Invalid secret. Allowed: a-z A-Z 0-9 _ - (max 256 chars).');
      }
      const secret = secretRaw || generateSecret6();
      const r = await api('/api/admin/album', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ albumId, title, secret })
      });
      if (!r.ok) {
        const t = await r.text();
        alert(`Create failed: ${r.status} ${t}`);
        return;
      }
      $('newAlbumId').value = '';
      $('newSecret').value = '';
      await refresh();
    };

    $('genSecretBtn').onclick = () => {
      const secretEl = $('newSecret');
      const bytes = new Uint8Array(3); // 3 bytes => 6 hex chars
      crypto.getRandomValues(bytes);
      let hex = "";
      for (const b of bytes) hex += b.toString(16).padStart(2, "0");
      secretEl.value = hex;
      try { secretEl.focus(); secretEl.select(); } catch {}
    };

    $('genAlbumIdBtn').onclick = async () => {
      const btn = $('genAlbumIdBtn');
      const descEl = $('newAlbumDesc');
      const albumIdEl = $('newAlbumId');
      const desc = String(descEl && descEl.value || '').trim();
      if (!desc) {
        alert('Enter a short description first (e.g. "семья на пляже")');
        return;
      }
      if (btn) btn.disabled = true;
      if (genAlbumIdStatusEl) genAlbumIdStatusEl.textContent = 'Generating...';
      try {
        const r = await api('/api/admin/generate-album-id', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ description: desc })
        });
        if (!r.ok) {
          const t = await r.text().catch(() => '');
          if (genAlbumIdStatusEl) genAlbumIdStatusEl.textContent = `Error: ${r.status}`;
          alert(`AI generation failed: ${r.status} ${t}`);
          return;
        }
        const data = await r.json().catch(() => null);
        const id = data && data.albumId ? String(data.albumId) : '';
        if (!id) {
          if (genAlbumIdStatusEl) genAlbumIdStatusEl.textContent = 'Error: empty result';
          alert('AI returned empty result');
          return;
        }
        if (albumIdEl) {
          albumIdEl.value = id;
          try { albumIdEl.focus(); albumIdEl.select(); } catch {}
        }
        if (genAlbumIdStatusEl) genAlbumIdStatusEl.textContent = `OK: ${id}`;
      } finally {
        if (btn) btn.disabled = false;
      }
    };

    refresh().catch(err => {
      statusEl.textContent = String(err);
    });
  </script>
</body>
</html>


