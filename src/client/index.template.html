<!-- GENERATED FILE: edit `src/client/index.template.html` and run `node scripts/build-assets.mjs` -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <title>OhMyPhoto</title>
  <meta name="robots" content="noindex,nofollow" />
  <link rel="preconnect" href="https://challenges.cloudflare.com" crossorigin>
  <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
</head>
<body>
  <h1 id="title">OhMyPhoto</h1>
  <div id="status"></div>
  <!-- Turnstile containers:
       - Invisible/offscreen is used first (no UI).
       - Modal is shown only if invisible execution can't get a token (likely needs interaction). -->
  <div id="turnstile-offscreen" style="position:absolute;left:-9999px;top:0;width:1px;height:1px;overflow:hidden;">
    <div id="turnstile-widget-invisible"></div>
  </div>
  <div id="turnstile-modal" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.35);z-index:9999;">
    <div style="background:#fff;border:1px solid #ddd;border-radius:10px;padding:16px;max-width:360px;width:calc(100% - 32px);">
      <div id="turnstile-widget-visible" style="min-height:72px;"></div>
    </div>
  </div>
  <div id="grid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:10px;"></div>

  <script>
    function getAlbumIdFromPath() {
      // expect /<albumId>
      const parts = location.pathname.split('/').filter(Boolean);
      return parts[0] || '';
    }

    // Cloudflare Turnstile site key (injected by build step)
    const TURNSTILE_SITE_KEY = '__TURNSTILE_SITE_KEY__';

    async function main() {
      const albumId = getAlbumIdFromPath();
      const secret = (location.hash || '').replace(/^#/, '');

      const statusEl = document.getElementById('status');
      const gridEl = document.getElementById('grid');
      const titleEl = document.getElementById('title');

      const setStatus = (s) => { statusEl.textContent = s; };

      if (!albumId) {
        setStatus('No albumId in URL. Expected /<albumId>#<secret>');
        return;
      }
      if (!secret) {
        setStatus('No secret in URL hash. Expected /<albumId>#<secret>');
        return;
      }

      setStatus('Loading...');

      async function fetchAlbumOnce(turnstileToken) {
        setStatus('Fetching album...');
        const controller = new AbortController();
        const timeoutMs = 15000;
        const timeout = setTimeout(() => controller.abort(new Error('Request timeout')), timeoutMs);
        try {
          const tApi = performance.now();
          const resp = await fetch(`/api/album/${encodeURIComponent(albumId)}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ secret, turnstileToken: String(turnstileToken || '') }),
            signal: controller.signal
          });
          return resp;
        } finally {
          clearTimeout(timeout);
        }
      }

      async function getTurnstileTokenOnce() {
        if (!TURNSTILE_SITE_KEY || TURNSTILE_SITE_KEY === 'YOUR_TURNSTILE_SITE_KEY') return '';
        try {
          // Wait for Turnstile script to load (poll with timeout)
          await new Promise((resolve) => {
            const startedAt = Date.now();
            const tick = () => {
              if (typeof turnstile !== 'undefined') return resolve();
              if (Date.now() - startedAt > 3000) return resolve(); // 3s timeout
              setTimeout(tick, 50);
            };
            tick();
          });

          if (typeof turnstile === 'undefined') return '';

          const modal = document.getElementById('turnstile-modal');

          // 1) Try invisible/offscreen first (no UI)
          const invisibleToken = await new Promise((resolve) => {
            let resolved = false;
            const overallTimeout = setTimeout(() => {
              if (resolved) return;
              resolved = true;
              resolve('');
            }, 2000); // if we can't get a token quickly, likely needs interaction

            const widgetId = turnstile.render('#turnstile-widget-invisible', {
              sitekey: TURNSTILE_SITE_KEY,
              callback: (t) => {
                if (resolved) return;
                resolved = true;
                clearTimeout(overallTimeout);
                resolve(t);
              },
              'error-callback': () => {
                if (resolved) return;
                resolved = true;
                clearTimeout(overallTimeout);
                resolve('');
              },
              size: 'invisible',
              execution: 'execute',
              appearance: 'interaction-only',
            });

            try { turnstile.reset(widgetId); } catch {}
            try { turnstile.execute(widgetId); } catch { resolve(''); }
          });
          if (invisibleToken) return invisibleToken;

          // 2) Fall back to interactive modal if invisible couldn't get a token
          if (modal) modal.style.display = 'flex';
          const visibleToken = await new Promise((resolve) => {
            let resolved = false;
            const timeout = setTimeout(() => {
              if (resolved) return;
              resolved = true;
              resolve('');
            }, 20000);

            const widgetId = turnstile.render('#turnstile-widget-visible', {
              sitekey: TURNSTILE_SITE_KEY,
              callback: (t) => {
                if (resolved) return;
                resolved = true;
                clearTimeout(timeout);
                resolve(t);
              },
              'error-callback': () => {
                if (resolved) return;
                resolved = true;
                clearTimeout(timeout);
                resolve('');
              },
              size: 'compact',
            });

            // For visible widget, user interaction may be required; no execute() call needed.
            try { turnstile.reset(widgetId); } catch {}
          });
          if (modal) modal.style.display = 'none';
          return visibleToken || '';
        } catch (err) {
          const modal = document.getElementById('turnstile-modal');
          if (modal) modal.style.display = 'none';
          return '';
        }
      }

      // Fast path: try without Turnstile. If server requires it, we'll get 403 and retry once.
      let resp = await fetchAlbumOnce('');
      if (resp.status === 403) {
        const token = await getTurnstileTokenOnce();
        resp = await fetchAlbumOnce(token);
      }

      if (resp.status === 404) {
        setStatus('Album not found (404)');
        return;
      }
      if (resp.status === 403) {
        setStatus('Forbidden (403): wrong secret / bot check failed');
        return;
      }
      if (!resp.ok) {
        setStatus(`Error: ${resp.status}`);
        return;
      }

      const data = await resp.json();
      const baseTitle = 'OhMyPhoto';
      const albumTitle = data.title || baseTitle;

      titleEl.textContent = albumTitle;
      document.title = albumTitle === baseTitle ? baseTitle : `${albumTitle} | ${baseTitle}`;

      if (data.files.length === 0) {
        setStatus('This is the correct link, but the photos havenâ€™t been uploaded here yet.');
      } else {
        setStatus('');
      }

      // Render previews if worker returns previewUrl
      gridEl.innerHTML = '';
      for (const f of data.files) {
        const wrap = document.createElement('div');
        wrap.style.border = '1px solid #ddd';
        wrap.style.padding = '8px';

        const img = document.createElement('img');
        img.loading = 'lazy';
        img.style.width = '100%';
        img.style.height = '160px';
        img.style.objectFit = 'cover';
        img.src = f.previewUrl || '';

        const a = document.createElement('a');
        a.textContent = f.name;
        a.href = f.photoUrl || '#';
        a.target = '_blank';
        a.rel = 'noreferrer';

        wrap.appendChild(img);
        wrap.appendChild(document.createElement('div')).appendChild(a);
        gridEl.appendChild(wrap);
      }
    }

    main().catch(err => {
      const msg = (err && err.name === 'AbortError')
        ? 'Request timed out. Try again.'
        : String(err && (err.stack || err.message || err));
      document.getElementById('status').textContent = msg;
    });
  </script>
</body>
</html>

